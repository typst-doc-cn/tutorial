#import "mod.typ": *

#show: book.page.with(title: "表达式")

#pro-tip[
  Typst借鉴了Rust，遵从「面向表达式编程」（expression-oriented programming）的哲学。它将所有的语句都根据可折叠规则（见后文）设计为表达式。
  + 如果一个语句能产生值，那么该语句的结果是按*控制流*顺序所产生所有值的折叠。
  + 否则，如果一个语句不能产生值，那么该语句的结果是```typc none```。
  + 特别地，任意类型 $T$ 的值 $v$ 与```typc none```折叠仍然是值本身。
  $ forall v in T union {"none"}, op("fold")_T (v, "none") = v $
]

== 表达式 <scripting-expression>

Typst中绝大部分语法结构都可作表达式，可以说学习完了所有表达式，则学会了Typst所有语法。当然，其吸取了一定历史经验，仅有少量的语句不是表达式。

#pro-tip[
  `show`语句和`set`语句不是表达式。
]

根据大的分类，可用的表达式可以分为5类（它们并非严格术语，而是为了方便教学而分类），他们是：
+ 代数运算表达式。
+ 逻辑比较表达式。
+ 逻辑运算表达式。
+ 赋值表达式。
+ 项。

其中第五项又是一个大类。我们上一章所学的所有常量、变量以及变量的应用都是项。块表达式也是项，将在本节后半部分详细介绍。

== 计算标准库
#todo-box[写完]
请参见#link("https://typst.app/docs/reference/foundations/calc")[Typst Reference - Calculation]。

== 浮点数陷阱

浮点数陷阱是指由于浮点转换或浮点精度问题导致的一系列逻辑问题。

// todo: 把基本字面量的运算和表达式挪过来

+ 类型比较陷阱。在运行期切记同时考虑到`float`和`int`两种类型：

  #code(```typ
  #type(2), #type(2.), #(type(2.) == int)
  ```)

  可见```typc 2.```与```typc 2```类型并不相同。```typc 2.```在数学上是整数，但以浮点数存储。

+ 大数类型陷阱。当数字过大时，其会被隐式转换为浮点数存储：

  #code(```typ
  #type(9000000000000000000000000000000)
  ```)

+ 整数运算陷阱。整数相除时会被转换为浮点数：

  #code(```typ
  #(10 / 4), #type(10 / 4) \
  #(12 / 4), #type(12 / 4) \
  ```)

+ 浮点误差陷阱。哪怕你的运算在数学上理论是可逆的，由于浮点数精度有限，也会误判结果：

  #code(```typ
  #(1000000 / 9e21 * 9e21), #((1000000 / 9e21 * 9e21) == 1000000)
  ```)

  这提示我们，正确的浮点比较需要考虑误差。例如以上两数在允许`1e-6`误差前提下是相等的：

  #code(```typ
  #(calc.abs((1000000 / 9e21 * 9e21) - 1000000) < 1e-6)
  ```)

+ 整数转换陷阱。为了转换类型，可以使用`int`，但有可能产生精度损失（就近取整）：

  #code(```typ
  #int(10 / 4),
  #int(12 / 4)
  ```)

  或有可能产生「截断」。（todo: typst v0.12.0已经不适用）

// #code(```typ
// #int(9000000000000000000000000000000)
// ```)

这些都是编程语言中的共通问题。凡是令数字保持有效精度，都会产生如上问题。

== 代数运算表达式 <grammar-arith-exp>

Typst支持对数字的算数运算，其中浮点运算遵守IEEE-754标准。整数和浮点数之间可以混合运算：

#code(```typ
//加     减        乘      除
#(1 + 2, 1.0 - 2, 1 * 2, 1 / 2 + 1)
```)

从上可以看出，整数和整数运算尽可能*保持*整数，但是整数和浮点数运算则结果变为浮点数。除法运算的结果是浮点数。算数之间遵守四则运算规则。

#pro-tip[
  更高级的运算，例如数字的位运算和数值计算隐藏在类型的方法和`calc`标准库中：

  #code(```typ
  #(0o755.bit-and(0o644)), // 8进制位运算
  #(calc.pow(9, 4)) // 9的4次方
  ```)

  请参考《》。
]

除了数字运算，字符串、数组等还支持加法和乘法运算。它们的加法实际上是连接操作，它们的乘法则是重复元素的累加。

#code(```typ
//乘         加
#("1"  * 2, "4"  + "5", ) \
#((1,) * 2, (4,) + (5,),)
```)

字典只支持加法操作。若有重复键值对，则右侧列表的键值对会覆盖左侧列表的键值对。

#code(```typ
#((a: 1) + (b: 2),
  (a: 1) + (b: 3, a: 2) + (a: 4 , c: 5))
```)

== 逻辑比较表达式 <grammar-logical-cmp-exp>

有三大简单比较关系：

#code(```typ
//大于    小于   等于
#(1 > 2, 1 < 2, 1 == 2)
```)

基于此，可以延申出三个方便脚本编辑的比较关系。

#code(```typ
//大于或等于 小于或等于 不等于
#(1 >= 2.0, 1 <= 1,  1 != 2)
```)

从数学角度，真正基本的关系另有其系，其中“小于或等于”是数学中的偏序关系，“等于”是数学中的等价关系。这两个关系可以衍生出其他四种关系，但是不太好理解。举例来讲，大于其实就是“小于等于”的否定；而小于则是“小于等于”但是不能“等于”。

注意：不推荐将整数与浮点数相互比较。具体请参考上一节所提及的浮点数陷阱。

字符串、数组和字典之间也是可以比较的，理解他们则必须从偏序关系和等价关系入手。

三种项的等价关系比较容易理解，说两字符串/数组/字典相等，则是在说二者有一样多的子项，且每个子项都一一相等。

#code(```typ
#((1, 1) == (1, 1)),
#((a: 1, c: (1, )) == (a: 1, c: (1, )))
```)

字典之间没有偏序关系，便只剩字符串和数组。偏序关系则需要指定一种排序规则。如果两字符串/数组不相等，则首先考虑它们的长度关系，长度小的一方是更小的：

#code(```typ
#("1"   <= "23"),
#((1, ) <= (2, 3, ))
```)

否则从前往后依次比较每一个子项，直到找到*第一个*不相等的子项，进而确定顺序。见下三例：

#code(```typ
#("1" <= "2", "113" <= "121", "2" <= "12")
```)

对于单个字符，我们依照字典序比较，其中容易理解地是数字字符顺序按字面递增。对于前两者，我们可以看到`"1"`比`"2"`小；进由此，故"113"比"121"小；尽管如此，优先判断长度关系，故"2"比"12"小。

从两种基础比较关系，其他四种比较关系也能被良好地定义，并在脚本中使用：

#code(```typ
#("1" > "2", "1" != "2",
  "1" < "2", "1" >= "2")
```)

== 逻辑运算表达式 <grammar-logical-calc-exp>

布尔值之间可以做“且”、“或”和“非”三种逻辑运算，并产生布尔类型的表达式：

#code(```typ
#(not false), #(false or false), #(true and false)
```)

真值表如下：

#{
  set align(center)
  table(
    columns: (33pt * 0.6,) * 2 + (33pt,) * 3,
    stroke: 0.5pt,
    $p$,
    $q$,
    $not p$,
    $p or q$,
    $p and q$,
    $0$,
    $0$,
    $1$,
    $0$,
    $0$,
    $0$,
    $1$,
    $1$,
    $1$,
    $0$,
    $1$,
    $0$,
    $0$,
    $1$,
    $0$,
    $1$,
    $1$,
    $0$,
    $1$,
    $1$,
  )
}

逻辑运算使用起来很简单，建议入门的同学找一些专题阅读，例如#link("https://zhuanlan.zhihu.com/p/82986019")[数理逻辑（1）——命题逻辑的基本概念]。但一旦涉及到对复杂事物的逻辑讨论，你就可能陷入了知识的海洋。关于逻辑运算已经形成一门学科，如有兴趣建议后续找一些书籍阅读，例如#link("https://www.xuetangx.com/course/THU12011001060/19316572")[逻辑学概论]。

本书自然不负责教你逻辑学。

== 赋值表达式 <grammar-assign-exp>

变量可以被赋予一个表达式的值。事实上，`let`表达式后的语法结构就是赋值表达式。

#code(```typ
#let a = 1; #a,
#(a = 10); #a
```)

除此之外，还有先加（减、乘或除）后赋值的变形。所有这些赋值语句都产生`none`值而非返回变量的值。

#code(```typ
#let a = 1; #a,
#repr(a += 2), #a, #repr(a -= 2), #a, #repr(a *= 2), #a, #repr(a /= 2), #a
```)

== 代码块 <grammar-code-block>

在Typst中，代码块和内容块是等同的。与「代码块」

- 代码块：按顺序包含一系列语句，内部为#term("code mode")。
- 内容块：按顺序包含一系列内容，内部为#term("markup mode")。

内容块（标记模式）内部没有语句的概念，一个个内容或元素按顺序排列。但你可以通过#mark("#")将解释器的「解释模式」从「标记模式」*临时*改为「脚本模式」。当执行完脚本后，将脚本结果转换成内容，并放置在「井号」处。

相比，代码块内部则有语句概念。每个语句可以是换行分隔，也可以是#mark(";")分隔。

#code(```typ
#{
  "a"
  "b"
} \ // 与下表达式等同：
#{ "a"; "b" }
```)

// 整数转浮点数：<grammar-int-to-float>

// #code(```typ
// #float(1), #(type(float(1)))
// ```)

// 布尔值转整数：<grammar-bool-to-int>

// #code(```typ
// #int(false), #(type(int(false))) \
// #int(true), #(type(int(true)))
// ```)

// 浮点数转整数：<grammar-float-to-int>

// #code(```typ
// #int(1), #(type(int(1)))
// ```)

// 数字转字符串：<grammar-num-to-str>

// #code(```typ
// #repr(str(1)), #(type(str(1)))
// #repr(str(.5)), #(type(str(.5)))
// ```)

// 布尔值转字符串：<grammar-bool-to-str>

// #code(```typ
// #repr(false), #(type(repr(false)))
// ```)

// 数字转布尔值：<grammar-int-to-bool>

// #code(```typ
// #let to-bool(x) = x != 0
// #repr(to-bool(0)), #(type(to-bool(0))) \
// #repr(to-bool(1)), #(type(to-bool(1)))
// ```)

// 表达式从感性地理解上就是检验执行一段代码是否对应产生一个值。精确来说，表达式是以下对象的集合：
// + 前述的各种「字面量」是表达式：
//   #code(```typ
//   // 这些是表达式
//   #none, #true, #1, #.2, #"s"
//   ```)
// + 「变量」是表达式：
//   #code(```typ
//   #let a = 1;
//   // 这是表达式
//   #a
//   ```)
// + 「括号表达式」（parenthesized expression）是表达式：
//   #code(```typ
//   // 这些是表达式
//   #(0), #(1+2), #((((((((1))))))))
//   ```)
// + 「函数调用」是表达式：
//   #code(```typ
//   #let add(a, b) = a + b
//   #let a = 1;
//   // 这是表达式
//   #add(a, 2)
//   ```)
// + 特别地，Typst中的「代码块」和「内容块」是表达式：
//   #code(```typ
//   // 这些是表达式
//   #repr({ 1 }), #repr([ 1 ]),
//   ```)
// + 特别地，Typst中的「if语句」、「for语句」和「while语句」等都是表达式：
//   #code(```typ
//   // 这些是表达式
//   #repr(if false [啊？]),
//   #repr(for _ in range(0) {}),
//   #repr(while false {}),
//   #repr(let _ = 1),
//   ```)
//   这些将在后文中介绍。
// + 情形1至情形7的所有对象作为项，任意项之间的「运算」也是表达式。

// 其中，情形1至情形3被称为「初始表达式」（primary expression），它们就像是表达式的种子，由其他操作继续组合生成更多表达式。

// 情形4至情形6本身都是经典意义上的「语句」（statement），它们由一个或多个子表达式组成，形成一个有新含义的表达式。在Typst中它们都被赋予了「值」的语义，因此它们也都是表达式。我们将会在后续文章中继续学习。

// 本节主要讲解情形7。由于情形1至情形6都可以作为情形7的项，不失一般性，我们仍然可以仅以「字面量」作为项讲解所有情形7的情况。
